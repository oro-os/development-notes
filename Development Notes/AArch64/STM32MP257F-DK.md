Contained here are notes for getting Oro booting on the [STM32MP257F-DK](https://www.st.com/en/evaluation-tools/stm32mp257f-dk.html) board ([mouser ID `511-STM32MP257F-DK`](https://www.mouser.de/ProductDetail/STMicroelectronics/STM32MP257F-DK?qs=NeOn4crkEuv9X8W3Ch%2FMaQ%3D%3D)).

## Boot protocol

The boot protocol is very hard to find documentation for. Here's ChatGPT's deep research response, in full:

---
### Boot Process Overview for STM32MP257F-DK

#### Boot ROM Sequence and Boot Sources

The STM32MP257F has an internal BootROM (in ROM memory) that executes at power-on. It reads the **BOOT0-BOOT3 pins** (configured by DIP switches on the DK board) to decide which interface to try first for a bootloader ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=At%20startup%2C%20the%20boot%20pins,USB%20boot%20for%20flash%20programming)). Supported boot sources include external flash and storage devices such as SD card (SDMMC interface), eMMC, NAND/NOR (QSPI) flash, and a serial USB DFU mode ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=Once%20the%20voltage%20has%20stabilized%2C,be%20found%20on%20the%20board)) ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%200%20Forced,)). In normal operation, the BootROM copies a bootloader (First Stage Boot Loader, FSBL) from the selected device into internal SRAM and then jumps to it ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=Once%20the%20image%20was%20verified%2C,statically%20beforehand%20to%20work%20properly)) ([GitHub - 4ms/stm32mp1-baremetal: Baremetal framework and example projects for the STM32MP15x Cortex-A7 based MPU](https://github.com/4ms/stm32mp1-baremetal#:~:text=store%20your%20application%2C%20the%20Cortex,load%20and%20start%20the%20application)). For example, on the STM32MP257F-DK (which has an SD slot and eMMC but no QSPI NOR), the BootROM will typically boot from the SD card if the DIP switches are set for SDMMC, or from eMMC if set accordingly ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=Once%20the%20voltage%20has%20stabilized%2C,be%20found%20on%20the%20board)) ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%200%20Forced,)). If the chosen boot source is not available or no valid image is found, the BootROM may fall back to a **serial boot mode** (USB DFU) to await programming commands (this is effectively the “Forced USB boot” mode) ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%200%20Forced,)). The boot source can also be locked via one-time programmable fuses (OTP) in production, but by default the DIP switches control it ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=Once%20the%20voltage%20has%20stabilized%2C,be%20found%20on%20the%20board)).

**Boot loader format:** The BootROM expects the bootloader in a specific format. On STM32MP2 devices, ST uses a special 256-byte **STM32 header** preceding the binary. This header contains a magic word, image size, load address, entry point, and an optional signature, among other fields ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=The%20bootROM%20now%20tries%20to,the%20bootROM%20will%20later%20execute)) ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=,text)). The BootROM will look for a valid header and then load the binary into SRAM (starting at a fixed address in SYSRAM) and jump to the entry point ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=,text)) ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=Once%20the%20image%20was%20verified%2C,statically%20beforehand%20to%20work%20properly)). Notably, when booting from SD or eMMC, the BootROM uses a GPT partition scheme: it searches for partitions named **“fsbl1”** and **“fsbl2”** (two copies of the FSBL for redundancy) ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=GPT)) ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=The%20SD%20card%20has%20to,inserted%20into%20a%20Linux%20host)). The FSBL partitions need to contain the properly formatted bootloader image for the ROM to load. (On STM32MP1/MP2, the ROM code will first look for a GPT; if found, it finds the partitions whose name begins with "fsbl" ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=The%20SD%20card%20has%20to,inserted%20into%20a%20Linux%20host)).) Typically, the first stage bootloader is either **TF-A (Trusted Firmware-A)** BL2 or a minimal U-Boot SPL, which is responsible for low-level init (clocks, DDR setup, etc.). The BootROM’s SRAM is limited (only ~256 KB for the image), so the FSBL must fit that size (ST notes the FSBL payload is limited to ~247 KB due to BootROM memory usage) ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=256%20Kbytes%20to%20512%20Kbytes,least%20two%20copies%20are%20embedded)).

#### On-Chip Firmware and What Needs Flashing

There is **no user-accessible internal flash** on the STM32MP257 for the Cortex-A35 or M33 cores – all executable code must reside in external memory or be loaded into RAM. The chip’s built-in BootROM (in system ROM) comes pre-programmed by ST, so you **do not flash the BootROM**. Instead, you provide your own bootloader externally (on SD, eMMC, QSPI, etc.). In other words, **the primary firmware that needs to be flashed is the bootloader and subsequent images on external storage**, not an on-chip flash.

The STM32MP257F is a heterogeneous SoC with both Cortex-A35 MPUs and a Cortex-M33 MCU. The BootROM can boot either the A-core or the M33 core depending on the boot mode pins (see Boot Mode section below). There is no dedicated flash memory for the M33 either – any M33 firmware must also be loaded into SRAM (or DDR) from external storage. In a typical Linux use-case, the A35 core boots first and can later load M33 firmware (e.g. via U-Boot or Linux remoteproc) ([STM32MP2 boot chain overview - stm32mpu - ST wiki](https://wiki.stmicroelectronics.cn/stm32mpu/wiki/STM32MP2_boot_chain_overview#:~:text=STM32MP2%20boot%20chain%20overview%20,TEE)). Alternatively, by changing the boot mode pins, you can have the M33 act as the primary boot processor (booting from SD or eMMC with its own firmware) ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%201%20SD,eMMC%20on%20SDMMC2)). In that scenario, the BootROM will load a firmware image for the M33 from the selected device into SRAM and start the M33 core. In summary, aside from blowing optional OTP fuses for secure boot or fixed boot source (advanced scenarios), **there is no on-chip nonvolatile firmware that the user must program** – you simply prepare the bootloader and firmware on an external boot device, and the BootROM will load it.

#### Pre-Installed Firmware and SD Card Structure

The STM32MP257F-DK kit comes with an SD card pre-loaded with ST’s demonstration software to showcase the board’s capabilities ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=3,4%20CAD%20resources)). This SD card image uses the standard STM32MP2 boot chain structure:

- **FSBL (First Stage Bootloader):** On the SD card, two GPT partitions named “fsbl1” and “fsbl2” contain the FSBL. In ST’s Linux distribution (OpenSTLinux), the FSBL is typically **Arm Trusted Firmware-A (TF-A)** BL2, possibly combined with a minimal U-Boot SPL, along with a device-tree blob appended ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=2%20Mbytes%20ssbl%20The%20second,least%20two%20copies%20are%20embedded)). The BootROM will load one of these (fsbl1 is primary, fsbl2 is backup) into internal RAM at reset.
- **SSBL (Second Stage Bootloader):** Following the FSBL, the next stage is usually **U-Boot** (often called SSBL in documentation). U-Boot is stored in its own partition (for example, a partition labeled “ssbl” of a couple of MB) ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=2%20Mbytes%20ssbl%20The%20second,least%20two%20copies%20are%20embedded)). The FSBL (TF-A) will initialize the hardware (clocks, DDR, etc.) and then load U-Boot into DDR RAM and hand control to it.
- **Linux OS and root filesystem:** The SD card also contains partitions for the Linux kernel, device tree, and root filesystem. Typically there is a **boot filesystem (bootfs)** partition (e.g. an EXT4 partition) containing the Linux kernel image (possibly in a FIT image or extlinux.conf) and device tree ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=64%20Mbytes%20bootfs%20The%20boot,file%20system%20contains)), and a **rootfs** partition for the OpenSTLinux root file system. In the demo image, once U-Boot starts, it will load the Linux kernel and DTB from the bootfs partition and boot Linux.
- **Coprocessor firmware:** In addition to the Linux side, the demo includes **STM32CubeMP2 demonstration firmware** for the Cortex-M33. This firmware is likely provided as a binary that U-Boot or Linux loads into the M33’s SRAM. For example, the DK’s demo might have the M33 core perform some real-time task (like sensor reading or LED control) in tandem with Linux. The pre-loaded SD card ensures that this M33 firmware is available (possibly on the bootfs or rootfs) and configured to load at startup. (Exact details depend on ST’s demo; often the M-core firmware can be started via U-Boot scripts or by the Linux remoteproc framework.)

According to the user manual, the board’s SD card comes with both the **OpenSTLinux Distribution** (Yocto-based Linux) and the **STM32CubeMP2 base demonstration** for the M33, ready to run out-of-the-box ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=3,4%20CAD%20resources)). When you power on the board with the SD card and the correct boot mode, it will go through TF-A → U-Boot → Linux. If a display is attached, a launcher GUI will appear after boot, indicating the demo is running ([STM32MP25 Evaluation boards - Starter Package - stm32mpu](https://wiki.st.com/stm32mpu/index.php?title=STM32MP25_Evaluation_boards_-_Starter_Package&oldid=115576#:~:text=When%20the%20boot%20process%20is,More%20detail)). This structure is important to understand, because any custom bootloader or firmware you create will need to fit into a similar structure (or replace parts of it) on the boot device.

#### Boot Mode DIP Switches (BOOT0-BOOT3)

The Discovery kit has DIP switches that configure the BOOT0, BOOT1, BOOT2, BOOT3 pins, selecting the boot source and which core is booted. These correspond to the “Boot pins” referenced in documentation ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=At%20startup%2C%20the%20boot%20pins,Forced%20USB%20boot%20for%20flash)). The user manual provides a table of common configurations ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=Table%204,0%20eMMC%20on%20SDMMC2)):

- **BOOT0=0, BOOT1=0, BOOT2=0, BOOT3=0:** _Forced USB boot (DFU mode)_ – This forces the BootROM into USB device mode on the USB OTG port for programming. This mode is used to flash devices via USB and does **not** attempt to boot from SD/eMMC ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%200%20Forced,)).
- **BOOT0=1, BOOT1=0, BOOT2=0, BOOT3=0:** Boot from **SD Card (SDMMC1)** on the Cortex-A35. This is the typical setting to boot Linux or a custom A35 application from the microSD slot ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=Forced%20USB%20boot%20for%20flash,0%20eMMC%20on%20SDMMC2)).
- **BOOT0=0, BOOT1=1, BOOT2=0, BOOT3=0:** Boot from **eMMC (SDMMC2)** on the Cortex-A35 ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%201%20SD,)). Use this if you have flashed your bootloader and OS to the on-board eMMC device.
- **BOOT0=0, BOOT1=0, BOOT2=1, BOOT3=1:** _Development boot mode_ – This is a special mode (often used by ST for development or JTAG boot). In this mode, the BootROM does not boot an application but instead likely allows debug access. (For general use, this mode is not typically needed).
- **BOOT0=1, BOOT1=1, BOOT2=1, BOOT3=0:** Boot from **SD Card (SDMMC1) on Cortex-M33** ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%201%20SD,eMMC%20on%20SDMMC2)). This means the M33 core will be the one booting from the SD instead of the A35. Use this if you want to run a _microcontroller-style_ program on the M33 without Linux/A35.
- **BOOT0=0, BOOT1=0, BOOT2=0, BOOT3=1:** Boot from **eMMC (SDMMC2) on Cortex-M33** ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%201%201%201%20,eMMC%20on%20SDMMC2)). The M33 core boots from eMMC in this case.

_(The table above is condensed from the documentation; not all combinations are shown here. For the full list, refer to the STM32MP257 datasheet or reference manual.)_ The DIP switches labeled on the board (often as SW1 and SW2) correspond to these BOOT pin settings. For example, to boot from the SD card (A35), set the switches so that BOOT0 is `High (1)` and BOOT1/2/3 are `Low (0)` as indicated ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=Forced%20USB%20boot%20for%20flash,0%20eMMC%20on%20SDMMC2)). For USB DFU mode, set all BOOT0-3 to `0` (usually all switches OFF) ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%200%20Forced,)). These switches give you a convenient way to select the boot source without hardware rework.

**Note:** In normal use you will boot the Cortex-A35 from SD or eMMC (BOOT0=1 or 0 as above). The Cortex-M33 boot options exist mainly if you want to use the board in a microcontroller-only context. Typically, if you boot the A35, the M33 will remain idle until firmware is loaded for it (or it might run a tiny stub). If you instead boot the M33 via DIP settings, the A35 will stay in reset while the M33 runs your code. Choose the mode that fits your application.

#### Using U-Boot in a Non-Linux/Bare-Metal Context

**Yes**, U-Boot can be used even if you are not running Linux. U-Boot is a general-purpose bootloader capable of loading and launching any arbitrary binary (bare-metal applications, RTOS kernels, etc.), not just Linux kernels. By default, ST’s U-Boot is configured to load Linux, but it can be repurposed or configured to boot another payload. There are a couple of ways to use U-Boot in a non-Linux context:

- **Manual boot via U-Boot shell:** You can interrupt U-Boot’s autoboot and use its command line to load your own program. For example, you might store a custom bare-metal application (like a “hello world” binary or ELF) on the SD card (in a FAT/EXT4 partition). From the U-Boot prompt, you could use commands like `fatload`/`ext4load` to load the binary into RAM, then use the `go` command (for a raw binary with a known address) or `bootelf` (for an ELF file) to execute it. U-Boot will jump to your code, effectively booting your custom firmware instead of Linux. This method requires no changes to U-Boot itself – you leverage its shell and commands.
- **Autoboot a custom payload:** You can also script U-Boot to automatically boot your payload. This involves setting environment variables (like `bootcmd`) to load and run your program instead of the Linux kernel. For instance, you could modify the U-Boot environment (or device tree or compile-time settings) so that on startup, it loads a file (e.g., `helloworld.bin`) into memory and executes it. This way, after the FSBL hands control to U-Boot, U-Boot will immediately launch your bare-metal app. Essentially, U-Boot would act as a minimal OS loader for your code.
- **Customizing or stripping U-Boot:** If you want to minimize overhead, you can configure U-Boot with fewer features (to improve boot time or memory usage). U-Boot’s configuration can be tuned via its menuconfig system. For example, you might remove unnecessary drivers or disable features like network, filesystems, etc., if all you need is to load a file from SD. The STM32MP25 platform uses the `stm32mp25_defconfig` as a base ([STM32MP25 U-Boot - stm32mpu - ST wiki](https://wiki.st.com/stm32mpu/wiki/STM32MP25_U-Boot#:~:text=STM32MP25%20U,same%20name%20as%20kernel)) – this can be modified for your needs. Keep in mind that U-Boot is fairly large, but it provides convenient infrastructure (drivers for SD, etc.) that you’d otherwise have to implement in a custom bootloader.

Using U-Boot has the advantage of reusing ST’s initialization code (for DDR, clocks, etc.) and device support, so you don’t have to write those from scratch. Essentially, you could let the ST-provided TF-A and U-Boot bring the system to a point where DDR and clocks are ready, then run your program. This is a common approach for early bare-metal development on these MPUs.

That said, it’s also possible to **replace U-Boot entirely with a custom bootloader** if you prefer. For example, some community projects provide lightweight bootloaders for the STM32MP1/MP2 that initialize hardware and jump to an application directly ([GitHub - 4ms/stm32mp1-baremetal: Baremetal framework and example projects for the STM32MP15x Cortex-A7 based MPU](https://github.com/4ms/stm32mp1-baremetal#:~:text=To%20run%20an%20application%20on,two%20bootloaders%20to%20choose%20from)) ([GitHub - 4ms/stm32mp1-baremetal: Baremetal framework and example projects for the STM32MP15x Cortex-A7 based MPU](https://github.com/4ms/stm32mp1-baremetal#:~:text=Bootloader%20Overview)). If you write your own FSBL or second-stage loader, you have full control. Just note that you will need to handle DDR initialization, clock setup, and possibly peripheral setup that the BootROM and Linux-oriented boot chain normally handle in TF-A/U-Boot. Many developers start with U-Boot (because it’s known-working) and later consider writing a smaller custom loader if needed.

In summary, **U-Boot can absolutely boot a non-Linux payload** – you just have to configure it or use its commands to do so. ST’s documentation itself focuses on Linux, but the bootloader mechanism is general. For instance, one could package a bare-metal program as if it were a Linux kernel and have U-Boot `bootm` it, or simply use `go` to jump to an arbitrary address. Community examples also show using U-Boot’s remoteproc feature to start the M33 core firmware while A35 runs something else ([GitHub - 4ms/stm32mp1-baremetal: Baremetal framework and example projects for the STM32MP15x Cortex-A7 based MPU](https://github.com/4ms/stm32mp1-baremetal#:~:text=,Wacky%2C%20but%20cool)), illustrating U-Boot’s flexibility. If your end goal is a totally minimal system (no Linux, no heavy OS), you can still use the ST boot chain up to U-Boot, then run your code.

#### Documentation and Resources

For detailed understanding, refer to both ST’s official documentation and community resources:

- **ST Official Documentation:**
    
    - **Discovery Kit User Manual (UM3385)** – Contains hardware info and boot switch settings. In particular, see the “Boot options” section for DIP switch (BOOT0-3) settings and boot modes ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=Table%204,0%20eMMC%20on%20SDMMC2)).
    - **STM32MP25 Datasheet/Reference Manual** – Provides the complete boot pin table and BootROM behavior details (e.g. all boot mode combinations, default BootROM timeouts, etc.).
    - **STM32MPU ST Wiki** – ST maintains a wiki for the MPUs. Relevant articles include the _Boot Chain Overview_, _ROM code overview_, and _Flash mapping_. These cover how the BootROM finds the FSBL, the required partition layout, and how TF-A, U-Boot, etc., are organized ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=The%20SD%20card%20has%20to,inserted%20into%20a%20Linux%20host)) ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=256%20Kbytes%20to%20512%20Kbytes,least%20two%20copies%20are%20embedded)). (For example, the wiki notes the BootROM looks for `fsbl1/fsbl2` partitions and that U-Boot occupies an “ssbl” partition ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=2%20Mbytes%20ssbl%20The%20second,least%20two%20copies%20are%20embedded)).)
    - **Application Notes** – ST provides app notes like AN5489 (hardware getting started) which mention boot pin usage ([[PDF] AN5489 - Getting started with STM32MP23/25xx MPUs hardware ...](https://www.st.com/resource/en/application_note/an5489-getting-started-with-stm32mp2325xx-mpus-hardware-development-stmicroelectronics.pdf#:~:text=,boot%20ROM%20after%20a%20reset)), and others for power (AN5727) which hint at bootloader responsibilities. While not solely about boot, they provide context (e.g., the PMIC app note notes that BOOT pins are sampled at reset by the ROM ([[PDF] AN5489 - Getting started with STM32MP23/25xx MPUs hardware ...](https://www.st.com/resource/en/application_note/an5489-getting-started-with-stm32mp2325xx-mpus-hardware-development-stmicroelectronics.pdf#:~:text=,boot%20ROM%20after%20a%20reset))).
    - **STM32CubeProgrammer User Manual** – This tool’s documentation will explain how to use USB DFU mode to flash the STM32MP25, which is relevant for programming the board without an ST-LINK.
- **Community and Educational Resources:**
    
    - **WerWolv’s Blog – “Getting a home-made OS running on STM32MP1”** – Although written for STM32MP157 (earlier generation), this in-depth blog post walks through the entire boot process, from power-on, BootROM, to crafting a custom OS bootloader ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=The%20STM32MP157C,custom%20kernel%20can%20be%20loaded)) ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=Once%20the%20voltage%20has%20stabilized%2C,be%20found%20on%20the%20board)). It demystifies how the BootROM loads the FSBL (including details of the STM32 header format ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=The%20bootROM%20now%20tries%20to,the%20bootROM%20will%20later%20execute))) and shows how to bring up a simple kernel on the STM32MP1. Many principles carry over to the STM32MP2.
    - **4ms STM32MP1 Baremetal Examples (GitHub)** – This repository ([GitHub - 4ms/stm32mp1-baremetal: Baremetal framework and example projects for the STM32MP15x Cortex-A7 based MPU](https://github.com/4ms/stm32mp1-baremetal#:~:text=To%20run%20an%20application%20on,two%20bootloaders%20to%20choose%20from)) contains bare-metal example projects for STM32MP1 (Cortex-A7) including a _“Minimal Boot” Hello World_ that demonstrates a simple bootloader and application ([GitHub - 4ms/stm32mp1-baremetal: Baremetal framework and example projects for the STM32MP15x Cortex-A7 based MPU](https://github.com/4ms/stm32mp1-baremetal#:~:text=,both%20A7%20cores%20in%20parallel)). It also has notes on using U-Boot vs a custom bootloader ([GitHub - 4ms/stm32mp1-baremetal: Baremetal framework and example projects for the STM32MP15x Cortex-A7 based MPU](https://github.com/4ms/stm32mp1-baremetal#:~:text=To%20run%20an%20application%20on,two%20bootloaders%20to%20choose%20from)). While targeted at MP1, it’s useful for understanding the process on MP2 (the MP2 is Cortex-A35, but boot flow is similar).
    - **ST Community Forums** – Many threads discuss bare-metal on STM32MP1/MP2. For example, users have asked about using the MPUs without Linux – ST’s official stance is that their support is Linux-focused, but community members share tips for bare-metal use ([Usage of STM32MP1xx without linux - STMicroelectronics Community](https://community.st.com/t5/stm32-mpus-products/usage-of-stm32mp1xx-without-linux/td-p/203464#:~:text=Usage%20of%20STM32MP1xx%20without%20linux,Linux%20or%20Android%20are%20supported)). There are also forum threads on loading M33 firmware on MP25 EV1 boards ([STM32MP257FxEV1 - M33 bare metal project](https://community.st.com/t5/stm32-mpus-software-development/stm32mp257fxev1-m33-bare-metal-project/td-p/757525#:~:text=Hi%20I%20am%20working%20with,there%20is%20no%20ready)).
    - **Bootlin OpenWrt for STM32MP2** – Bootlin has added OpenWrt support for STM32MP2 and provides an _OpenWrt feed documentation_ that includes steps to build and flash images on STM32MP257F-EV1 ([OpenWrt support for STM32MP updated and STM32MP2 added - Bootlin's blog](https://bootlin.com/blog/openwrt-support-for-stm32mp-updated-and-stm32mp2-added/#:~:text=Image)). This can be a practical guide to see how a third-party sets up the bootloaders and does flashing on MP2 (even if you’re not using OpenWrt). It uses ST’s TF-A and U-Boot under the hood ([OpenWrt support for STM32MP updated and STM32MP2 added - Bootlin's blog](https://bootlin.com/blog/openwrt-support-for-stm32mp-updated-and-stm32mp2-added/#:~:text=The%20components%20of%20the%20ST,BSP%20were%20updated%20as%20follows)), so it’s a good reference for the bootloader versions and configurations.
    - **AN2606 (STM32 Bootloader interfaces)** – Although more relevant to STM32 MCUs, it lists which interfaces the internal ROM bootloader supports for various chips. The MP25’s BootROM information will be in the STM32MP25 section of AN2606, confirming it supports USB DFU, etc.

Leveraging these resources will give you both the official “intended” use (Linux boot) and the know-how from others who have done bare-metal or custom boot solutions on STM32MP-series devices.

#### Flashing and Programming the Board (Without ST-LINK)

The on-board ST-LINK on the Discovery kit is primarily for debugging (JTAG/SWD) and providing a virtual COM port. It **does not function as a mass-storage programmer for the STM32MP25’s external flash**, and it cannot directly flash the eMMC or SD card with your code (unlike how ST-LINK can load internal flash on MCUs). Therefore, you’ll use one of the following methods to program your bootloader/firmware:

- **SD Card Method (Removable media):** This is the simplest approach for development. Since the board can boot from the microSD card, you can prepare an SD card image on your host PC. Using tools like `fdisk` or `gdisk`, create a GPT on the SD card with the required partitions (“fsbl1”, “fsbl2”, “ssbl”, etc.). Then copy your bootloader binaries into those partitions. ST provides a preset "Flashlayout" file and tools with STM32CubeProgrammer to automate this partitioning and flashing, or you can do it manually. Once the SD is prepared, insert it into the board, set BOOT pins for SD boot, and power on. The BootROM will load your custom bootloader from the SD. This method allows quick iteration – just rewrite the card as needed. **Tip:** You can use Linux `dd` to write binaries to specific partition offsets, or mount partitions if formatted (e.g., FAT for bootfs). ST’s wiki notes that using STM32CubeProgrammer is an easy way to get the correct GPT setup on an SD card ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=The%20SD%20card%20has%20to,inserted%20into%20a%20Linux%20host)).
- **USB DFU Method (BootROM programming mode):** The STM32MP257F BootROM includes a USB device DFU implementation. By setting all BOOT0-3 pins to 0 (the “Forced USB boot” mode) ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%200%20Forced,)) and resetting the board, the device will enumerate on USB as a DFU capable device. You can then use **STM32CubeProgrammer** (ST’s official tool) on your PC to connect via USB. CubeProgrammer can send your binaries over USB and program external memory (e.g., write to the eMMC or QSPI flash if present, or even load directly into DDR for testing). In practice, you would use CubeProgrammer’s GUI or CLI, select the DFU interface, and provide a “Flash layout” script or manually specify addresses to flash your bootloader, etc. This method is needed to program the on-board eMMC (since you can’t remove the eMMC). For example, you could flash a complete Linux image to eMMC using DFU. For your custom bootloader, you might flash just the FSBL/SSBL areas. The USB DFU approach is the one to use for “factory programming” the board without relying on the SD card.
- **U-Boot’s DFU / Ethernet / etc.:** If you already have U-Boot running (say from SD), you can use U-Boot’s capabilities to flash other devices. U-Boot has a DFU mode as well, and can access the eMMC, allowing you to transfer new images via USB or network and write to flash. This is an advanced usage but worth mentioning: for instance, you could boot the board from SD, interrupt into U-Boot, then use `mmc write` commands to program the eMMC with a new image. Or use U-Boot’s `dfu` command to expose eMMC partitions to a host PC via USB. This can be handy for updating the bootloader on eMMC without a special hardware programmer.
- **JTAG/SWD (OpenOCD) for RAM loading:** While not a flashing method per se, you can use the ST-LINK with tools like **OpenOCD** to load and execute code directly in the target’s RAM. For debugging purposes, OpenOCD can connect to the A35 or M33 via JTAG and you can use GDB to upload a program into DDR or SRAM and run it. This is great for iterative development (no need to continually rewrite an SD card for every test). As one developer noted, using OpenOCD with ST-LINK allowed him to dramatically speed up his edit-compile-run cycle on the STM32MP1 by loading code directly into memory for testing ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=,for%20debugging%20would%20light%20up)) ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=This%20process%20usually%20took%20between,and%20debugging%20right%20within%20VSCode)). However, note that this doesn’t **store** the program permanently – it’s only for development/testing. Once you power-cycle, that program is lost, so for a standalone boot you still need one of the above flashing methods.

In summary, since ST-LINK on this board doesn’t directly flash the user code storage, your go-to methods are **SD card boot for development** and **USB DFU (CubeProgrammer) for programming internal non-removable flash (eMMC)**. The ST Wiki has a guide on using the `dfu-util` tool (an open-source DFU host utility) to load U-Boot over USB as well ([How to load U-Boot with dfu-util - stm32mpu - ST wiki](https://wiki.st.com/stm32mpu/wiki/How_to_load_U-Boot_with_dfu-util#:~:text=How%20to%20load%20U,Windows%2C%20supports%20the%20DFU%20standard)) – this is essentially doing the same thing as CubeProgrammer in a more manual way. Many developers find it convenient to prototype on SD card (because it’s easy to swap images) and then, once things work, flash the final image to eMMC via DFU.

#### Bringing Up a Custom Bootloader – “Hello World” Example

Finally, to get your custom bootloader or minimal kernel running on the STM32MP257F-DK, here’s a step-by-step outline of the first steps:

1. **Set Up Toolchain and Sources:** Ensure you have an appropriate cross-compilation toolchain for A35 (Armv8-A, 64-bit). You can use the Linaro GCC toolchain or the one from STM32MPU distribution. You’ll also want source code for necessary boot components. For a simple “hello world” at the console, you have a few options:
    
    - Use ST’s existing boot chain and insert your code at some stage (e.g., as a payload for U-Boot to run, or as a replacement for U-Boot).
    - Use a minimal open-source bootloader as a template (for example, the 4ms **MP1-Boot** or the TF-A minimal BL2).
    - Or modify U-Boot to print hello and stop.
    
    A good starting point is to download ST’s TF-A and U-Boot sources (available on ST’s GitHub in the stm32mp2 branches ([OpenWrt support for STM32MP updated and STM32MP2 added - Bootlin's blog](https://bootlin.com/blog/openwrt-support-for-stm32mp-updated-and-stm32mp2-added/#:~:text=The%20components%20of%20the%20ST,BSP%20were%20updated%20as%20follows)), or via the OpenSTLinux package). This gives you a reference for initialization code and device trees.
    
2. **Decide Boot Chain Architecture:** For the first attempt, the simplest reliable approach is:
    
    - **Use TF-A BL2 as FSBL** (first stage) – it will initialize the system (PMIC, clocks, DDR). You can use the TF-A provided by ST with minimal changes (just ensure it knows to load your next stage).
    - **Use U-Boot (or your custom code) as the second stage.** You can either take U-Boot proper and configure it to immediately jump to a payload, or replace U-Boot with a custom program of your own.
    
    One simple method: _Make your “hello world” program appear as if it were the Linux kernel to U-Boot._ For example, you could have U-Boot chainload an ELF that prints “Hello World” and then halts. This requires building your program and perhaps packaging it in a format U-Boot understands (uImage or FIT). However, doing this requires U-Boot to run, which adds a few seconds of overhead and complexity.
    
    Alternatively, you can skip U-Boot and have TF-A directly launch your payload. TF-A on STM32MP2 is designed to load a BL33 (which is normally U-Boot). You can configure TF-A with a custom BL33: for instance, compile your bare-metal app as a Position-Independent ELF and tell TF-A to use that as BL33. This way, after TF-A finishes init, it jumps straight into your app. This approach is a bit more advanced but eliminates U-Boot entirely. If you’re new to TF-A, you might stick with U-Boot first for simplicity.
    
3. **Prepare the Boot Media (SD card):** Using the methods described above, create a bootable SD card with your images. The typical layout:
    
    - Create GPT partitions: two for FSBL (fsbl1, fsbl2), one for SSBL (u-boot). For example, fsbl1 and fsbl2 might be 512KB each, and ssbl maybe 2MB.
    - Flash your TF-A binary to both fsbl1 and fsbl2 partitions (or the same image to both for redundancy). Ensure the binary has the proper STM32 header. (If you build TF-A using ST’s scripts, it will produce a `tf-a.stm32` or similar file that includes the header.)
    - Flash your second stage (U-Boot or custom payload) to the ssbl partition. If using U-Boot, this is the `u-boot.stm32` binary (U-Boot with ST header). If using a custom payload directly as BL33, you might not need a separate U-Boot partition – it could be packaged with TF-A’s FIP in some cases. But to keep it simple, you can treat your payload as “U-Boot” from the perspective of flash layout. For example, if you replaced U-Boot with your own code, just name it and place it where U-Boot would go.
    - If using U-Boot and intending to load a separate hello-world binary from filesystem, you’ll also need a small boot filesystem partition (e.g., FAT32) to hold that binary and perhaps an `extlinux.conf` or script. But if you build the hello world into U-Boot or as BL33, you don’t need an extra partition.
    
    STM32CubeProgrammer can be used with a CSV “FlashLayout” to automate partition creation and image flashing. For instance, ST provides FlashLayout files for Linux images; you can adapt one for your images. Alternatively, use `sgdisk` (to make partitions by name) and `dd`. Remember, the partition _names_ must start with “fsbl” for the BootROM to recognize them ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=The%20SD%20card%20has%20to,inserted%20into%20a%20Linux%20host)) (actual names like fsbl1, fsbl2 are common).
    
4. **Configure Boot Switches:** Set the BOOT0-3 DIP switches to boot from the SD card with the A35 core (Boot0=1, Boot1=0, Boot2=0, Boot3=0) ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=Forced%20USB%20boot%20for%20flash,0%20eMMC%20on%20SDMMC2)). Ensure the board is powered off when changing DIP switches, then power it on.
    
5. **Serial Console Setup:** Connect to the board’s UART console (via the ST-LINK VCP or another UART connector, as documented in the manual) to observe boot messages. Use a terminal program at the appropriate baud rate (115200 bps is typical for STM32MP boards). This will allow you to see messages from TF-A, U-Boot, or your own program.
    
6. **Power On and Observe:** With your custom SD inserted and DIP set, power on or reset the board.
    
    - If everything is correct, you should see the BootROM load TF-A (you might not see much from BootROM except maybe a debug message if enabled, but typically first output is from TF-A or U-Boot).
    - TF-A should print some logs (unless you turned them off) about initializing DDR, etc., then handing off to BL33.
    - If using U-Boot, you’ll see the U-Boot banner. If you configured U-Boot to auto-run your app, it might then immediately load/print from it. Otherwise, you can drop to the U-Boot shell and run your commands to load your app.
    - If you set up TF-A to directly jump to your payload, you should see your **“Hello World”** message appear on the console as that payload executes. For example, a minimal bare-metal app could initialize the UART and print "Hello world from Cortex-A35" to confirm everything works.
7. **Troubleshooting:** If nothing appears on the console, double-check the DIP switch settings and that your images were flashed to the correct partitions/offsets. Also verify the UART connections. You may use STM32CubeProgrammer’s UART or USB connection to see if the chip is in wait mode (for example, if it falls back to DFU due to a boot failure, CubeProgrammer might detect it). Ensure the FSBL image is properly formatted with the STM32 header – a bad header will cause the BootROM to skip it or fail. The ST documentation (and community posts) have details on the header format ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=FSBL)) ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=,text)) – using ST’s provided tools to generate the binaries (like the `.stm32` files) can avoid header mistakes.
    
8. **Iterate:** Once you see the "Hello World" print, congratulations – you have a custom bootloader running! From here, you can expand your code. If you used U-Boot, you might next replace U-Boot with your own program entirely to shorten the boot path. If you booted directly into a bare-metal app, you might add functionality (clock configs, enabling caches, etc.). Always keep the console prints working as a debug aid (maybe add an LED toggle as well to indicate life). As you progress, you can also explore running the M33 core (for instance, have A35 boot and then kick off an M33 bare-metal app via U-Boot’s remoteproc framework ([GitHub - 4ms/stm32mp1-baremetal: Baremetal framework and example projects for the STM32MP15x Cortex-A7 based MPU](https://github.com/4ms/stm32mp1-baremetal#:~:text=,Wacky%2C%20but%20cool)) or via Linux later, depending on your needs).
    

By following these steps, you leverage the STM32MP257F-DK’s flexible boot system to get a minimal custom firmware up and running. Start simple (print to serial) before adding complexity. And refer to the official docs and community examples frequently – they provide configuration snippets and memory addresses that can save you time. Good luck with your custom bootloader development!

**Sources:**

1. STMicroelectronics – _STM32MP257F-DK User Manual (UM3385)_ ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=At%20startup%2C%20the%20boot%20pins,USB%20boot%20for%20flash%20programming)) ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%200%20Forced,)) ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=0%200%200%201%20SD,eMMC%20on%20SDMMC2)) ([Discovery kit with STM32MP257F MPU - User manual](https://www.mouser.com/pdfDocs/um3385-discovery-kit-with-stm32mp257f-mpu-stmicroelectronics.pdf?srsltid=AfmBOop21ErFQi8xeDGb2xlLVfyXnipY_G85EfLbTZ2E7k63id2MWXLT#:~:text=3,4%20CAD%20resources))
2. STMicroelectronics Wiki – _STM32 MPU Flash mapping_ (BootROM and partition details) ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=256%20Kbytes%20to%20512%20Kbytes,least%20two%20copies%20are%20embedded)) ([STM32 MPU Flash mapping - stm32mpu](https://wiki.stmicroelectronics.cn/stm32mpu/index.php?title=STM32_MPU_Flash_mapping&oldid=75203#:~:text=The%20SD%20card%20has%20to,inserted%20into%20a%20Linux%20host))
3. WerWolv Blog – _Getting a home-made OS running on STM32MP1_ (boot process and header format) ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=Once%20the%20voltage%20has%20stabilized%2C,be%20found%20on%20the%20board)) ([Getting a home-made OS running on a STM32MP1 based development board | WerWolv](https://werwolv.net/blog/mp1os#:~:text=The%20bootROM%20now%20tries%20to,the%20bootROM%20will%20later%20execute))
4. 4ms Github – _STM32MP1 Baremetal Examples_ (bootloader overview and examples) ([GitHub - 4ms/stm32mp1-baremetal: Baremetal framework and example projects for the STM32MP15x Cortex-A7 based MPU](https://github.com/4ms/stm32mp1-baremetal#:~:text=store%20your%20application%2C%20the%20Cortex,load%20and%20start%20the%20application)) ([GitHub - 4ms/stm32mp1-baremetal: Baremetal framework and example projects for the STM32MP15x Cortex-A7 based MPU](https://github.com/4ms/stm32mp1-baremetal#:~:text=,both%20A7%20cores%20in%20parallel))
5. Bootlin Blog – _OpenWrt support for STM32MP2_ (mentions of STM32MP25 and resources) ([OpenWrt support for STM32MP updated and STM32MP2 added - Bootlin's blog](https://bootlin.com/blog/openwrt-support-for-stm32mp-updated-and-stm32mp2-added/#:~:text=The%20components%20of%20the%20ST,BSP%20were%20updated%20as%20follows))